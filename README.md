connectauth
===========

[![Build](https://github.com/akshayjshah/connectauth/actions/workflows/ci.yaml/badge.svg?branch=main)](https://github.com/akshayjshah/connectauth/actions/workflows/ci.yaml)
[![Report Card](https://goreportcard.com/badge/go.akshayshah.org/connectauth)](https://goreportcard.com/report/go.akshayshah.org/connectauth)
[![GoDoc](https://pkg.go.dev/badge/go.akshayshah.org/connectauth.svg)](https://pkg.go.dev/go.akshayshah.org/connectauth)

`connectauth` provides flexible authentication for [`connect-go`][connect]
servers. It works with any authentication function, covers both unary and
streaming RPCs, and runs efficiently.

## Installation

```
go get go.akshayshah.org/connectauth
```

## Usage

```go
package main

import (
  "context"
  "fmt"
  "net/http"

  "github.com/bufbuild/connect-go"
  "go.akshayshah.org/connectauth"
)

// Our authentication logic is just a function.
func authenticate(ctx context.Context, req *connectauth.Request) (any, error) {
  const passphrase = "open-sesame"
  if req.Header.Get("Authorization") != "Bearer "+passphrase {
    // If authentication fails, we return an error. connectauth.Errorf is a
    // convenient shortcut to produce an error coded with
    // connect.CodeUnauthenticated.
    return nil, connectauth.Errorf("try %q as a bearer token instead", passphrase)
  }
  // Once we've authenticated the request, we can return the authenticated
  // identity. The identity gets attached to the context passed to subsequent
  // interceptors and our service implementation.
  return "Ali Baba", nil
}

// This constructor would normally be generated by protoc-gen-connect-go. For
// this example, we'll use a small stub.
func NewHelloServiceHandler(svc any, opts ...connect.HandlerOption) (string, http.Handler) {
  return "/hello.v1/Hello", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    // Service implementations can retrieve the authenticated identity of the
    // caller from the context.
    identity := connectauth.GetIdentity(r.Context())
    fmt.Fprintf(w, "Hello, %v!", identity)
  })
}

func main() {
  mux := http.NewServeMux()
  mux.Handle(NewHelloServiceHandler(struct{}{}))
  // Before starting the HTTP server, wrap the whole mux in our authenticating
  // middleware.
  middleware := connectauth.NewMiddleware(authenticate)
  http.ListenAndServe("localhost:8080", middleware.Wrap(mux))
}
```

## Status: Unstable

This module is currently _unstable_, but I hope to release a stable 1.0 by
mid-2023.

It supports the [two most recent major releases][go-support-policy] of Go.
Within those parameters, `connectauth` follows semantic versioning. Once I cut
a stable release, no breaking changes will be made without incrementing the
major version.

## Legal

Offered under the [MIT][license].

[connect]: https://github.com/bufbuild/connect-go
[go-support-policy]: https://golang.org/doc/devel/release#policy
[license]: https://github.com/akshayjshah/connectauth/blob/main/LICENSE
